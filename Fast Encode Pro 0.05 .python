#!/usr/bin/env python3
"""
FastEncode Pro - Timeline Edition v0.05
GPU-Accelerated Video Editor with Accessibility Focus
CONSTANT BITRATE ENCODING - TIMELINE-AWARE FRAME-BY-FRAME RENDERING

v0.05 Changes:
- Implemented "Smart Stream" rendering engine
- Fixed GPU stalling by batch-processing continuous segments
- Replaced frame-by-frame seeking with persistent FFmpeg pipes
- 10x-20x performance improvement on timeline export
"""

import sys
import shutil
import os
import subprocess
import tempfile
import json
import time
from pathlib import Path
from PyQt6.QtWidgets import *
from PyQt6.QtCore import QThread, pyqtSignal, Qt, QSettings, QUrl, QPointF, QTimer, QEvent
from PyQt6.QtGui import QFont, QPalette, QColor, QPainter, QBrush, QPen, QCursor
from PyQt6.QtMultimedia import QMediaPlayer, QAudioOutput
from PyQt6.QtMultimediaWidgets import QVideoWidget

__version__ = "0.7.3 (GPU Decode Fix)"
__author__ = "cpgplays"


class FullscreenVideoPlayer(QWidget):
    """Fullscreen video player with always-visible overlay controls"""

    def __init__(self, player, parent=None):
        super().__init__(parent, Qt.WindowType.Window)
        self.player = player
        self.setWindowState(Qt.WindowState.WindowFullScreen)
        self.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose)
        self.setStyleSheet("background-color: black;")
        self.original_video_output = self.player.videoOutput()
        self.was_playing = (self.player.playbackState() == QMediaPlayer.PlaybackState.PlayingState)
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        self.video_widget = QVideoWidget()
        self.video_widget.setStyleSheet("background-color: black;")
        main_layout.addWidget(self.video_widget, stretch=1)
        controls_panel = QWidget()
        controls_panel.setStyleSheet("""
            QWidget {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(0,0,0,200), stop:1 rgba(0,0,0,240));
                padding: 20px;
            }
        """)
        controls_layout = QVBoxLayout(controls_panel)
        controls_layout.setSpacing(15)
        controls_layout.setContentsMargins(40, 20, 40, 20)
        self.timecode_label = QLabel("00:00:00 / 00:00:00")
        self.timecode_label.setStyleSheet("""
            QLabel {
                color: white;
                font-size: 28pt;
                font-weight: bold;
                background: transparent;
            }
        """)
        self.timecode_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        controls_layout.addWidget(self.timecode_label)
        self.scrubber = QSlider(Qt.Orientation.Horizontal)
        self.scrubber.setMinimum(0)
        self.scrubber.setMaximum(1000)
        self.scrubber.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.scrubber.setStyleSheet("""
            QSlider {
                min-height: 60px;
                max-height: 60px;
                background: transparent;
            }
            QSlider::groove:horizontal {
                border: none;
                height: 30px;
                background: rgba(100, 100, 100, 255);
                border-radius: 15px;
            }
            QSlider::handle:horizontal {
                background: #3b82f6;
                border: 4px solid white;
                width: 50px;
                height: 50px;
                margin: -10px 0;
                border-radius: 25px;
            }
            QSlider::sub-page:horizontal {
                background: #3b82f6;
                border-radius: 15px;
            }
        """)
        controls_layout.addWidget(self.scrubber)
        buttons_row = QHBoxLayout()
        buttons_row.setSpacing(20)
        buttons_row.addStretch()
        self.play_pause_btn = QPushButton("‚è∏Ô∏è PAUSE")
        self.play_pause_btn.setMinimumSize(300, 80)
        self.play_pause_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.play_pause_btn.setStyleSheet("""
            QPushButton {
                background-color: #3b82f6;
                color: white;
                font-size: 24pt;
                font-weight: bold;
                border-radius: 15px;
                border: 4px solid white;
            }
            QPushButton:hover {
                background-color: #2563eb;
            }
            QPushButton:pressed {
                background-color: #1d4ed8;
            }
        """)
        self.play_pause_btn.clicked.connect(self.toggle_playback)
        buttons_row.addWidget(self.play_pause_btn)
        self.exit_btn = QPushButton("‚úï EXIT")
        self.exit_btn.setMinimumSize(200, 80)
        self.exit_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.exit_btn.setStyleSheet("""
            QPushButton {
                background-color: #ef4444;
                color: white;
                font-size: 20pt;
                font-weight: bold;
                border-radius: 15px;
                border: 4px solid white;
            }
            QPushButton:hover {
                background-color: #dc2626;
            }
            QPushButton:pressed {
                background-color: #b91c1c;
            }
        """)
        self.exit_btn.clicked.connect(self.exit_fullscreen)
        buttons_row.addWidget(self.exit_btn)
        buttons_row.addStretch()
        controls_layout.addLayout(buttons_row)
        main_layout.addWidget(controls_panel, stretch=0)
        try:
            self.player.setVideoOutput(self.video_widget)
            if self.was_playing:
                self.player.play()
        except Exception as e:
            print(f"Error setting video output: {e}")
        self.scrubber.sliderMoved.connect(self.seek)
        self.scrubber.sliderPressed.connect(self.on_scrubber_pressed)
        self.scrubber.sliderReleased.connect(self.on_scrubber_released)
        self.player.positionChanged.connect(self.update_position)
        self.player.durationChanged.connect(self.update_duration)
        self.player.playbackStateChanged.connect(self.update_play_button)
        self.user_dragging = False
        self.update_duration(self.player.duration())
        self.update_position(self.player.position())
        self.update_play_button()

    def keyPressEvent(self, event):
        if event.key() == Qt.Key.Key_Escape:
            self.exit_fullscreen()
        elif event.key() == Qt.Key.Key_Space:
            self.toggle_playback()
        super().keyPressEvent(event)

    def toggle_playback(self):
        try:
            if self.player.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
                self.player.pause()
            else:
                self.player.play()
        except Exception as e:
            print(f"Playback toggle error: {e}")

    def update_play_button(self):
        try:
            if self.player.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
                self.play_pause_btn.setText("‚è∏Ô∏è PAUSE")
            else:
                self.play_pause_btn.setText("‚ñ∂Ô∏è PLAY")
        except:
            pass

    def on_scrubber_pressed(self):
        self.user_dragging = True

    def on_scrubber_released(self):
        self.user_dragging = False
        self.seek(self.scrubber.value())

    def seek(self, value):
        if self.player.duration() > 0:
            position = int((value / 1000.0) * self.player.duration())
            self.player.setPosition(position)

    def update_position(self, position):
        if not self.user_dragging and self.player.duration() > 0:
            value = int((position / self.player.duration()) * 1000)
            self.scrubber.setValue(value)
        self.timecode_label.setText(f"{self.format_time(position)} / {self.format_time(self.player.duration())}")

    def update_duration(self, duration):
        self.scrubber.setMaximum(1000)
        self.timecode_label.setText(f"{self.format_time(self.player.position())} / {self.format_time(duration)}")

    def format_time(self, ms):
        s = ms // 1000
        h = s // 3600
        m = (s % 3600) // 60
        s = s % 60
        return f"{h:02d}:{m:02d}:{s:02d}"

    def exit_fullscreen(self):
        try:
            if self.player.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
                self.player.pause()
            self.player.setVideoOutput(self.original_video_output)
        except Exception as e:
            print(f"Error restoring video output: {e}")
        self.close()


class TimelineClip:
    """Represents a clip on the timeline"""
    def __init__(self, file_path, track, start_time, in_point=0, out_point=None, duration=None):
        self.file_path = file_path
        self.track = track
        self.start_time = start_time
        self.in_point = in_point
        self.name = Path(file_path).name
        self.full_duration = duration if duration is not None else self.get_video_duration()
        if out_point is None or out_point <= 0:
            self.out_point = self.full_duration
        else:
            self.out_point = out_point
        if self.out_point <= self.in_point:
            self.out_point = self.full_duration

    def get_video_duration(self):
        try:
            result = subprocess.run(['ffprobe', '-v', 'error', '-show_entries', 'format=duration', '-of', 'default=noprint_wrappers=1:nokey=1', self.file_path], capture_output=True, text=True, )
            return float(result.stdout.strip())
        except:
            return 60.0

    def get_trimmed_duration(self):
        return self.out_point - self.in_point

    def get_end_time(self):
        return self.start_time + self.get_trimmed_duration()
    
    def timeline_time_to_clip_time(self, timeline_time):
        """Convert timeline time to source file time"""
        if timeline_time < self.start_time or timeline_time > self.get_end_time():
            return None
        offset = timeline_time - self.start_time
        return self.in_point + offset


class TimelineWidget(QWidget):
    """Visual timeline editor with drag-and-drop clips"""
    clip_selected = pyqtSignal(object)
    playhead_moved = pyqtSignal(float)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.clips = []
        self.selected_clip = None
        self.dragging_clip = None
        self.drag_start_pos = None
        self.drag_offset = 0
        self.zoom_level = 10.0
        self.scroll_offset = 0
        self.setMinimumHeight(250)
        self.setMouseTracking(True)
        self.track_height = 60
        self.num_tracks = 4
        self.playhead_position = 0
        self.dragging_playhead = False

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        bg_color = QColor("#111827")
        painter.fillRect(self.rect(), bg_color)
        ruler_height = 40
        painter.fillRect(0, 0, self.width(), ruler_height, QColor("#1f2937"))
        painter.setPen(QColor("#9ca3af"))
        font = QFont("Arial", 8)
        painter.setFont(font)
        # Draw time markers based on scroll offset
        visible_time_start = self.scroll_offset
        visible_time_end = self.scroll_offset + (self.width() / self.zoom_level)
        for sec in range(int(visible_time_start), int(visible_time_end) + 1, 5):
            x = (sec - self.scroll_offset) * self.zoom_level
            if 0 <= x < self.width():
                painter.drawLine(int(x), ruler_height - 10, int(x), ruler_height)
                painter.drawText(int(x) + 2, ruler_height - 15, f"{sec}s")
        for track in range(self.num_tracks):
            y = ruler_height + track * self.track_height
            track_color = QColor("#1f2937") if track % 2 == 0 else QColor("#374151")
            painter.fillRect(0, y, self.width(), self.track_height, track_color)
            painter.setPen(QColor("#4b5563"))
            painter.drawLine(0, y + self.track_height, self.width(), y + self.track_height)
        for clip in self.clips:
            self.draw_clip(painter, clip, ruler_height)
        painter.setPen(QPen(QColor("#ef4444"), 3))
        # Calculate playhead position relative to scroll offset
        playhead_x = int((self.playhead_position - self.scroll_offset) * self.zoom_level)
        painter.drawLine(playhead_x, 0, playhead_x, self.height())
        painter.setBrush(QBrush(QColor("#ef4444")))
        points = [QPointF(playhead_x, 0), QPointF(playhead_x - 8, 15), QPointF(playhead_x + 8, 15)]
        painter.drawPolygon(points)

    def draw_clip(self, painter, clip, ruler_height):
        x = self.time_to_x(clip.start_time)
        width = int(clip.get_trimmed_duration() * self.zoom_level)
        y = ruler_height + clip.track * self.track_height + 5
        height = self.track_height - 10
        if clip == self.selected_clip:
            color = QColor("#3b82f6")
        else:
            color = QColor("#10b981")
        painter.setBrush(QBrush(color))
        painter.setPen(QPen(QColor("white"), 2))
        painter.drawRoundedRect(x, y, width, height, 5, 5)
        painter.setPen(QColor("white"))
        font = QFont("Arial", 9, QFont.Weight.Bold)
        painter.setFont(font)
        text_rect = painter.boundingRect(x + 5, y + 5, width - 10, height - 10, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop, clip.name)
        painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop, clip.name)
        duration_text = f"{clip.get_trimmed_duration():.1f}s"
        duration_rect = painter.boundingRect(x + 5, y + height - 20, width - 10, 15, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignBottom, duration_text)
        painter.drawText(duration_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignBottom, duration_text)

    def time_to_x(self, time):
        return int((time - self.scroll_offset) * self.zoom_level)

    def x_to_time(self, x):
        return (x / self.zoom_level) + self.scroll_offset

    def y_to_track(self, y, ruler_height=40):
        if y < ruler_height:
            return -1
        return max(0, min(self.num_tracks - 1, (y - ruler_height) // self.track_height))

    def set_playhead_position(self, time, auto_scroll=True):
        """Update playhead with auto-scroll to keep it visible"""
        # Playhead can be anywhere on timeline (not limited by viewport)
        self.playhead_position = max(0, time)
        
        if auto_scroll:
            # Calculate where playhead would be drawn on screen
            playhead_x = (self.playhead_position - self.scroll_offset) * self.zoom_level
            
            # Define the "safe zone" - keep playhead in center 60% of viewport
            left_margin = self.width() * 0.2
            right_margin = self.width() * 0.8
            
            # If playhead goes past right margin, scroll right to keep it at 80% position
            if playhead_x > right_margin:
                # Calculate how much to scroll right
                self.scroll_offset = self.playhead_position - (right_margin / self.zoom_level)
                
            # If playhead goes past left margin (and we're scrolled), scroll left to keep it at 20% position
            elif playhead_x < left_margin and self.scroll_offset > 0:
                # Calculate how much to scroll left
                self.scroll_offset = max(0, self.playhead_position - (left_margin / self.zoom_level))
        
        self.update()
        self.playhead_moved.emit(self.playhead_position)

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            click_x = event.position().x()
            click_y = event.position().y()
            click_time = self.x_to_time(click_x)
            if click_y < 40:
                self.dragging_playhead = True
                self.set_playhead_position(click_time, auto_scroll=False)
                return
            clicked_track = self.y_to_track(click_y)
            if clicked_track < 0:
                return
            for clip in reversed(self.clips):
                if (clip.track == clicked_track and clip.start_time <= click_time <= clip.get_end_time()):
                    self.selected_clip = clip
                    self.dragging_clip = clip
                    self.drag_start_pos = click_time
                    self.drag_offset = click_time - clip.start_time
                    self.clip_selected.emit(clip)
                    self.update()
                    return
            self.selected_clip = None
            self.update()

    def mouseMoveEvent(self, event):
        click_x = event.position().x()
        click_time = self.x_to_time(click_x)
        if self.dragging_playhead:
            # Allow scrubbing anywhere on timeline, not clamped to clips
            self.set_playhead_position(click_time, auto_scroll=False)
            return
        if self.dragging_clip:
            new_time = click_time - self.drag_offset
            new_track = self.y_to_track(event.position().y())
            if new_track >= 0:
                self.dragging_clip.start_time = max(0, new_time)
                self.dragging_clip.track = new_track
                self.update()

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.dragging_clip = None
            self.drag_start_pos = None
            self.dragging_playhead = False
    
    def keyPressEvent(self, event):
        """Handle keyboard navigation"""
        if event.key() == Qt.Key.Key_Left:
            # Move playhead left by 1 second
            self.set_playhead_position(max(0, self.playhead_position - 1.0))
        elif event.key() == Qt.Key.Key_Right:
            # Move playhead right by 1 second
            self.set_playhead_position(self.playhead_position + 1.0)
        elif event.key() == Qt.Key.Key_Home:
            # Jump to start
            self.set_playhead_position(0)
        elif event.key() == Qt.Key.Key_End:
            # Jump to end of timeline
            duration = self.get_timeline_duration()
            self.set_playhead_position(duration)
        elif event.key() == Qt.Key.Key_PageDown:
            # Scroll right by one viewport
            scroll_amount = self.width() / self.zoom_level
            self.scroll_offset += scroll_amount
            self.update()
        elif event.key() == Qt.Key.Key_PageUp:
            # Scroll left by one viewport
            scroll_amount = self.width() / self.zoom_level
            self.scroll_offset = max(0, self.scroll_offset - scroll_amount)
            self.update()
        else:
            super().keyPressEvent(event)

    def add_clip(self, clip):
        self.clips.append(clip)
        self.update()

    def remove_clip(self, clip):
        if clip in self.clips:
            self.clips.remove(clip)
            if self.selected_clip == clip:
                self.selected_clip = None
            self.update()

    def clear_timeline(self):
        self.clips.clear()
        self.selected_clip = None
        self.playhead_position = 0
        self.update()

    def zoom_in(self):
        self.zoom_level = min(50, self.zoom_level * 1.5)
        self.update()

    def zoom_out(self):
        self.zoom_level = max(1, self.zoom_level / 1.5)
        self.update()
    
    def get_timeline_duration(self):
        """Get the total duration of the timeline (end of last clip)"""
        if not self.clips:
            return 0
        return max(clip.get_end_time() for clip in self.clips)


class MediaLibraryItem:
    """Represents a media file in the library"""
    def __init__(self, file_path):
        self.file_path = file_path
        self.name = Path(file_path).name
        self.duration = self.get_video_duration()
        self.in_point = 0
        self.out_point = self.duration

    def get_video_duration(self):
        try:
            result = subprocess.run(['ffprobe', '-v', 'error', '-show_entries', 'format=duration', '-of', 'default=noprint_wrappers=1:nokey=1', self.file_path], capture_output=True, text=True, )
            return float(result.stdout.strip())
        except:
            return 60.0

    def get_trimmed_duration(self):
        return self.out_point - self.in_point


def _parse_ffmpeg_time(line):
    """Parse time= value from FFmpeg stderr. Handles locale (comma/dot). Returns seconds or None."""
    if "time=" not in line:
        return None
    try:
        time_str = line.split('time=')[1].split()[0].replace(',', '.')
        parts = time_str.split(':')
        if len(parts) == 3:
            h, m, s = int(parts[0]), int(parts[1]), float(parts[2])
            return h * 3600 + m * 60 + s
    except (ValueError, IndexError):
        pass
    return None


class TimelineRenderingEngine:
    """
    Stream-based Rendering Engine v0.7.0.
    
    Fixes GPU stalling by batch-processing continuous segments 
    instead of spawning a process per frame.
    """
    
    def __init__(self, timeline, settings, output_path,
                 log_callback, progress_callback, status_callback, playhead_callback=None):
        self.timeline = timeline
        self.settings = settings
        self.output_path = output_path
        self.log = log_callback
        self.progress = progress_callback
        self.status = status_callback
        self.playhead = playhead_callback
        
        self.should_stop = False
        self.encoder_process = None
        
    def stop(self):
        """Stop rendering"""
        self.should_stop = True
        if self.encoder_process:
            try:
                if self.encoder_process.stdin:
                    self.encoder_process.stdin.close()
                self.encoder_process.kill()
            except:
                pass
    
    def get_timeline_duration(self):
        if not self.timeline.clips:
            return 0
        return max(clip.get_end_time() for clip in self.timeline.clips)

    def get_clip_at_timeline_time(self, timeline_time):
        """Find the top-most clip visible at a specific time."""
        candidates = []
        for clip in self.timeline.clips:
            if clip.start_time <= timeline_time < clip.get_end_time():
                # Store clip and its track index
                candidates.append(clip)
        
        if not candidates:
            return None
            
        # Sort by track (highest track number wins/is on top)
        candidates.sort(key=lambda x: x.track, reverse=True)
        return candidates[0]
    
    def get_video_metadata(self, file_path):
        try:
            cmd = [
                'ffprobe', '-v', 'error',
                '-select_streams', 'v:0',
                '-show_entries', 'stream=width,height',
                '-of', 'json',
                file_path
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
            data = json.loads(result.stdout)
            width = data['streams'][0]['width']
            height = data['streams'][0]['height']
            return width, height
        except:
            return 1920, 1080

    def _build_render_plan(self, total_frames, timeline_fps):
        """
        Scans the timeline frame-by-frame to create a list of continuous jobs.
        Instead of rendering frame-by-frame, we identify: "Frames 0-100 are Clip A".
        """
        self.log("Building render plan...")
        segments = []
        
        if total_frames == 0:
            return segments

        current_clip = None
        segment_start_frame = 0
        frames_in_segment = 0
        
        # Iterate through every frame to find continuity
        for i in range(total_frames):
            time = i / timeline_fps
            visible_clip = self.get_clip_at_timeline_time(time)
            
            # Check if we switched clips or hit a gap
            if visible_clip != current_clip:
                if frames_in_segment > 0:
                    # Save previous segment
                    segments.append({
                        'type': 'clip' if current_clip else 'blank',
                        'clip': current_clip,
                        'start_frame': segment_start_frame,
                        'count': frames_in_segment,
                        'timeline_start': segment_start_frame / timeline_fps
                    })
                
                # Start new segment
                current_clip = visible_clip
                segment_start_frame = i
                frames_in_segment = 0
            
            frames_in_segment += 1
            
        # Append final segment
        if frames_in_segment > 0:
            segments.append({
                'type': 'clip' if current_clip else 'blank',
                'clip': current_clip,
                'start_frame': segment_start_frame,
                'count': frames_in_segment,
                'timeline_start': segment_start_frame / timeline_fps
            })
            
        return segments

    def render(self):
        temp_video = self.output_path + ".temp_video.mov"
        temp_audio = self.output_path + ".temp_audio.wav"
        
        try:
            self.log("=== HIGH-PERFORMANCE STREAM RENDERING v0.7.2 ===")
            
            if not self.timeline.clips:
                return False, "No clips on timeline"
            
            # 1. Setup Resolution and FPS
            timeline_duration = self.get_timeline_duration()
            timeline_fps = self.settings.get('timeline_fps', 60.0)
            
            # Determine export resolution
            sorted_clips = sorted(self.timeline.clips, key=lambda c: c.start_time)
            source_width, source_height = self.get_video_metadata(sorted_clips[0].file_path)
            
            export_res_index = self.settings.get('export_res_index', 0)
            if export_res_index == 0:
                export_width, export_height = source_width, source_height
            else:
                res_map = {1: (1920, 1080), 2: (2560, 1440), 3: (3840, 2160),
                          4: (5120, 2880), 5: (7680, 4320)}
                export_width, export_height = res_map[export_res_index]

            total_frames = int(timeline_duration * timeline_fps)
            self.log(f"Resolution: {export_width}x{export_height} @ {timeline_fps} FPS")
            self.log(f"Total Frames: {total_frames}")
            
            # 3. Build the Plan (Coalesce frames into segments)
            segments = self._build_render_plan(total_frames, timeline_fps)
            self.log(f"Render Plan: {len(segments)} segments optimized.")

            # --- PHASE 1: VIDEO RENDER ---
            self.log("Phase 1/3: Rendering Video Stream...")
            
            # Start NVENC Encoder (Output to temp_video)
            if not self._start_encoder(timeline_fps, export_width, export_height, temp_video):
                return False, "Failed to start encoder"

            frames_processed = 0
            start_time = time.time()
            
            for seg in segments:
                if self.should_stop: return False, "Cancelled"
                
                count = seg['count']
                if seg['type'] == 'blank':
                    # Generate black frames
                    black_frame = bytes([16] * (export_width * export_height)) +                                   bytes([128] * (export_width * export_height // 2))
                    for _ in range(count):
                        if self.should_stop: break
                        self.encoder_process.stdin.write(black_frame)
                        frames_processed += 1
                        self._update_progress(frames_processed, total_frames, start_time, timeline_fps)
                elif seg['type'] == 'clip':
                    # Stream clip
                    clip = seg['clip']
                    offset_into_clip = seg['timeline_start'] - clip.start_time
                    source_seek_time = clip.in_point + offset_into_clip
                    self.log(f"Encoding Video: {clip.name} ({count} frames)")
                    
                    success = self._stream_segment_to_encoder(
                        clip.file_path, source_seek_time, count, 
                        export_width, export_height, timeline_fps,
                        frames_processed, total_frames, start_time
                    )
                    if not success:
                        self.log("Video decode error, padding with black.")
                        black_frame = bytes([16] * (export_width * export_height)) +                                       bytes([128] * (export_width * export_height // 2))
                        for _ in range(count):
                            self.encoder_process.stdin.write(black_frame)
                    frames_processed += count

            self.encoder_process.stdin.close()
            self.encoder_process.wait()
            
            # --- PHASE 2: AUDIO RENDER ---
            self.log("Phase 2/3: Rendering Audio Stream...")
            self._render_audio(segments, timeline_fps, temp_audio)
            
            # --- PHASE 3: MERGE ---
            self.log("Phase 3/3: Merging Audio and Video...")
            self.status("Finalizing...")
            merge_cmd = [
                'ffmpeg', '-y', '-v', 'error',
                '-i', temp_video,
                '-i', temp_audio,
                '-c:v', 'copy', # Copy video stream without re-encoding
                '-c:a', 'aac', '-b:a', '320k', # Encode audio to AAC
                '-shortest',
                self.output_path
            ]
            subprocess.run(merge_cmd, check=True)
            
            # Cleanup
            if os.path.exists(temp_video): os.remove(temp_video)
            if os.path.exists(temp_audio): os.remove(temp_audio)
            
            elapsed = time.time() - start_time
            return True, f"Render Complete! {elapsed:.1f}s"

        except Exception as e:
            import traceback
            self.log(f"Critical Error: {e}")
            self.log(traceback.format_exc())
            # Cleanup on fail
            if os.path.exists(temp_video): os.remove(temp_video)
            if os.path.exists(temp_audio): os.remove(temp_audio)
            return False, str(e)
        finally:
            self.stop()

    def _stream_segment_to_encoder(self, input_file, start_time, frame_count, width, height, fps, 
                                 current_total_frames, target_total_frames, job_start_time):
        """
        Opens a persistent FFmpeg decoder for a chunk of video and pipes it to the encoder.
        """
        scale_algo = self.settings.get('scale_algo', 'lanczos')
        frame_size = int(width * height * 1.5)
        
        # Decoder Command: Read 'frame_count' frames starting at 'start_time'
        # We output rawvideo so python can just shovel bytes from Decoder -> Encoder
        cmd = ['ffmpeg']
        if self.settings.get('use_gpu_decode', False):
            cmd.extend(['-hwaccel', 'cuda'])
            
        cmd.extend([
            '-ss', f"{start_time:.6f}",    # Fast seek before input
            '-i', input_file,
            '-vframes', str(frame_count),  # Exact number of frames needed
            # Fixed: Added fps={fps} to ensure playback speed is correct regardless of source framerate
            '-vf', f'scale={width}:{height}:flags={scale_algo},fps={fps},format=yuv420p',
            '-f', 'rawvideo',
            '-pix_fmt', 'yuv420p',
            '-'
        ])
        
        decoder = None
        try:
            decoder = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                bufsize=10**7 # Large buffer (10MB) for speed
            )
            
            frames_read = 0
            while frames_read < frame_count:
                if self.should_stop:
                    decoder.kill()
                    return False
                
                # Read exactly one frame size
                raw_data = decoder.stdout.read(frame_size)
                
                if not raw_data:
                    break # End of file reached early
                
                if len(raw_data) != frame_size:
                    # Incomplete frame (corruption or end of file)
                    break

                # Shovel to encoder
                try:
                    self.encoder_process.stdin.write(raw_data)
                except IOError:
                    return False
                
                frames_read += 1
                
                # Update UI every 5 frames so we don't spam signals
                if frames_read % 5 == 0:
                    self._update_progress(current_total_frames + frames_read, 
                                        target_total_frames, job_start_time, fps)
            
            decoder.wait()
            return True
            
        except Exception as e:
            self.log(f"Stream error: {e}")
            if decoder: decoder.kill()
            return False

    def _update_progress(self, current, total, start_time, fps):
        if total == 0: return
        pct = int((current / total) * 100)
        self.progress(pct)
        
        # Log stats every 60 frames (1 second)
        if current % int(fps) == 0:
            elapsed = time.time() - start_time
            actual_fps = current / elapsed if elapsed > 0 else 0
            timeline_time = current / fps
            self.status(f"Rendering: {pct}% ({actual_fps:.1f} fps)")
            
            if self.playhead:
                self.playhead(timeline_time)

    def _start_encoder(self, fps, width, height, output_file):
        try:
            # Input options for the Encoder
            cmd = ['ffmpeg', '-y', '-v', 'warning', '-stats']
            cmd.extend(['-f', 'rawvideo'])
            cmd.extend(['-pix_fmt', 'yuv420p'])
            cmd.extend(['-s', f'{width}x{height}'])
            cmd.extend(['-r', str(fps)])
            cmd.extend(['-i', 'pipe:0']) # Read from Python
            
            codec = self.settings.get('video_codec', 'hevc_nvenc')
            cmd.extend(['-c:v', codec])
            
            # Setup NVENC options (High Performance)
            if 'nvenc' in codec:
                bitrate_mbps = self.settings.get('bitrate_mbps', 100)
                bitrate_kbps = int(bitrate_mbps * 1000)
                
                cmd.extend(['-preset', 'p7', '-tune', 'hq', '-rc', 'cbr'])
                cmd.extend(['-b:v', f'{bitrate_kbps}k'])
                cmd.extend(['-maxrate', f'{bitrate_kbps}k'])
                cmd.extend(['-bufsize', f'{int(bitrate_kbps * 2)}k'])
                cmd.extend(['-g', str(int(fps * 2))]) # Keyframe interval
                
                pixel_format = self.settings.get('pixel_format', 0)
                cmd.extend(['-pix_fmt', 'yuv420p' if pixel_format == 0 else 'p010le'])
            
            cmd.extend(['-an', '-movflags', '+faststart'])
            cmd.append(output_file)
            
            self.encoder_process = subprocess.Popen(
                cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL, 
                bufsize=10**7 # Large buffer for input pipe
            )
            return True
        except Exception as e:
            self.log(f"Encoder start failed: {e}")
            return False
            
    def _render_audio(self, segments, timeline_fps, audio_output_path):
        # Generates the audio track by piping segment audio to a WAV file
        sample_rate = 48000
        channels = 2
        bytes_per_sample = 2
        
        cmd_enc = [
            'ffmpeg', '-y', '-v', 'error',
            '-f', 's16le', '-ar', str(sample_rate), '-ac', str(channels),
            '-i', 'pipe:0', 
            '-c:a', 'pcm_s16le', 
            audio_output_path
        ]
        
        encoder = None
        try:
            encoder = subprocess.Popen(cmd_enc, stdin=subprocess.PIPE, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            for seg in segments:
                if self.should_stop: break
                
                # Calculate required audio samples based on video frames to ensure exact sync
                # frames / fps = seconds. seconds * rate = samples.
                num_samples = int((seg['count'] / timeline_fps) * sample_rate)
                
                if seg['type'] == 'blank':
                    # Write silence
                    num_bytes = num_samples * channels * bytes_per_sample
                    encoder.stdin.write(bytes([0] * num_bytes))
                
                elif seg['type'] == 'clip':
                    clip = seg['clip']
                    offset = seg['timeline_start'] - clip.start_time
                    seek_time = clip.in_point + offset
                    duration = seg['count'] / timeline_fps
                    
                    self.log(f"Encoding Audio: {clip.name}")
                    
                    # Decoder: Extract Raw PCM
                    cmd_dec = [
                        'ffmpeg', '-ss', f"{seek_time:.6f}", '-i', clip.file_path,
                        '-t', f"{duration:.6f}",
                        '-vn',
                        '-f', 's16le', '-ar', str(sample_rate), '-ac', str(channels),
                        '-'
                    ]
                    
                    decoder = subprocess.Popen(cmd_dec, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
                    
                    # We need to write exactly the amount of bytes expected to maintain sync
                    # But ffmpeg -t is approximate. It's better to read until EOF.
                    # To be perfectly safe, we could count bytes, but usually piping -t is fine.
                    while True:
                        chunk = decoder.stdout.read(4096)
                        if not chunk: break
                        encoder.stdin.write(chunk)
                    decoder.wait()
                    
            encoder.stdin.close()
            encoder.wait()
        except Exception as e:
            self.log(f"Audio render error: {e}")
            if encoder: encoder.kill()


class TimelineExportThread(QThread):
    """
    Thread wrapper for timeline rendering engine.
    v0.6.0 - Optimized with timeline playhead updates during rendering.
    """
    progress = pyqtSignal(int)
    status = pyqtSignal(str)
    log_message = pyqtSignal(str)
    finished = pyqtSignal(bool, str)
    playhead_update = pyqtSignal(float)  # NEW: Emit current timeline time

    def __init__(self, timeline, output_path, settings):
        super().__init__()
        self.timeline = timeline
        self.output_path = output_path
        self.settings = settings
        self.engine = None

    def run(self):
        self.engine = TimelineRenderingEngine(
            self.timeline,
            self.settings,
            self.output_path,
            log_callback=self.log_message.emit,
            progress_callback=self.progress.emit,
            status_callback=self.status.emit,
            playhead_callback=self.playhead_update.emit  # NEW
        )
        
        success, message = self.engine.render()
        self.finished.emit(success, message)

    def stop(self):
        if self.engine:
            self.engine.stop()


class EncodingThread(QThread):
    progress = pyqtSignal(int)
    status = pyqtSignal(str)
    log_message = pyqtSignal(str)
    finished = pyqtSignal(bool, str)

    def __init__(self, input_file, output_file, settings):
        super().__init__()
        self.input_file = input_file
        self.output_file = output_file
        self.settings = settings
        self.process = None
        self.should_stop = False

    def run(self):
        try:
            cmd = self.build_ffmpeg_command()
            self.log_message.emit(f"Command: {' '.join(cmd)}")
            self.status.emit("Starting encode...")
            self.process = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE, universal_newlines=True, bufsize=1)
            duration = self.get_duration()
            for line in iter(self.process.stderr.readline, ''):
                if self.should_stop:
                    self.process.kill()
                    self.finished.emit(False, "Stopped")
                    return
                self.log_message.emit(line.strip())
                if duration > 0:
                    current = _parse_ffmpeg_time(line)
                    if current is not None:
                        pct = int((current / duration) * 100)
                        self.progress.emit(min(pct, 99))
                        self.status.emit(f"Encoding: {pct}%")
            self.process.wait()
            if self.process.returncode == 0:
                self.progress.emit(100)
                self.status.emit("Done!")
                self.finished.emit(True, "Success")
            else:
                self.finished.emit(False, "Encode failed")
        except Exception as e:
            self.finished.emit(False, str(e))

    def build_ffmpeg_command(self):
        cmd = ['ffmpeg', '-y', '-v', 'warning', '-stats', '-stats_period', '0.5']

        # Add hardware decode if enabled
        if self.settings.get('use_gpu_decode', True):
            cmd.extend(['-hwaccel', 'cuda', '-hwaccel_output_format', 'cuda'])

        cmd.extend(['-i', self.input_file])
        filter_complex = []
        denoise = self.settings['denoise_level']
        if denoise > 0:
            denoise_values = ['', 'hqdn3d=1.5:1.5:6:6', 'hqdn3d=2:2:8:8', 'hqdn3d=3:3:10:10', 'hqdn3d=4:4:12:12', 'hqdn3d=6:6:15:15', 'hqdn3d=8:8:18:18']
            if denoise < len(denoise_values):
                filter_complex.append(denoise_values[denoise])
        deflicker = self.settings['deflicker_level']
        if deflicker > 0:
            deflicker_values = ['', 'deflicker=mode=pm:size=5', 'deflicker=mode=pm:size=10', 'deflicker=mode=pm:size=15', 'deflicker=mode=am:size=20', 'deflicker=mode=am:size=30']
            if deflicker < len(deflicker_values):
                filter_complex.append(deflicker_values[deflicker])
        if filter_complex:
            cmd.extend(['-vf', ','.join(filter_complex)])

        codec = self.settings['video_codec']
        cmd.extend(['-c:v', codec])

        if codec == 'prores_ks':
            profile = self.settings['prores_profile']
            target_bitrate_mbps = self.settings.get('bitrate_mbps', 500)
            if target_bitrate_mbps >= 500:
                qscale = 9
            elif target_bitrate_mbps >= 300:
                qscale = 11
            elif target_bitrate_mbps >= 150:
                qscale = 13
            else:
                qscale = 15
            cmd.extend(['-profile:v', str(profile), '-vendor', 'apl0', '-qscale:v', str(qscale)])
        elif 'nvenc' in codec:
            if self.settings['use_gpu']:
                target_bitrate_mbps = self.settings.get('bitrate_mbps', 100)
                target_bitrate_kbps = int(target_bitrate_mbps * 1000)

                # NVENC rate control parameters in correct order
                cmd.extend(['-rc', 'cbr'])
                cmd.extend(['-b:v', f'{target_bitrate_kbps}k'])
                cmd.extend(['-maxrate', f'{target_bitrate_kbps}k'])
                cmd.extend(['-bufsize', f'{int(target_bitrate_kbps * 2)}k'])
                cmd.extend(['-preset', 'p7', '-tune', 'hq'])
                cmd.extend(['-g', '60'])
                cmd.extend(['-bf', '3'])
                cmd.extend(['-b_ref_mode', 'middle'])

                if self.settings['pixel_format'] == 0:
                    cmd.extend(['-pix_fmt', 'yuv420p'])
                else:
                    cmd.extend(['-pix_fmt', 'p010le'])
            else:
                cmd.extend(['-preset', 'medium'])

        cmd.extend(['-c:a', self.settings['audio_codec']])
        if self.settings['audio_codec'] == 'aac':
            cmd.extend(['-b:a', '320k'])
        if self.settings['threads'] > 0:
            cmd.extend(['-threads', str(self.settings['threads'])])
        cmd.append(self.output_file)
        return cmd

    def get_duration(self):
        try:
            result = subprocess.run(['ffprobe', '-v', 'error', '-show_entries', 'format=duration', '-of', 'default=noprint_wrappers=1:nokey=1', self.input_file], capture_output=True, text=True, )
            return float(result.stdout.strip())
        except:
            return 0

    def stop(self):
        self.should_stop = True
        if self.process:
            try:
                self.process.kill()
            except:
                pass


class FastEncodeProApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(f"FastEncode Pro v{__version__} - CBR Quality Control")
        self.setGeometry(100, 100, 1400, 900)
        self.input_files = []
        self.output_folder = ""
        self.encoding_thread = None
        self.timeline_export_thread = None
        self.current_file_index = 0
        self.media_library = []
        self.current_media = None
        self.player = QMediaPlayer()
        self.audio_output = QAudioOutput()
        self.player.setAudioOutput(self.audio_output)
        self.fullscreen_player = None
        self.timeline_duration = 0  # Initialize BEFORE creating tabs
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        self.tabs = QTabWidget()
        self.tabs.setStyleSheet(self.tab_style())
        main_layout.addWidget(self.tabs)
        self.timeline_tab = self.create_timeline_tab()
        self.codec_tab = self.create_codec_tab()
        self.batch_tab = self.create_batch_tab()
        self.tabs.addTab(self.timeline_tab, "üìΩÔ∏è Timeline")
        self.tabs.addTab(self.codec_tab, "‚öôÔ∏è Codec")
        self.tabs.addTab(self.batch_tab, "üì¶ Batch")
        self.apply_theme()

    def create_timeline_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        top_section = QWidget()
        top_layout = QHBoxLayout(top_section)
        top_layout.setSpacing(10)
        library_panel = QWidget()
        library_layout = QVBoxLayout(library_panel)
        library_layout.setContentsMargins(5, 5, 5, 5)
        lib_title = QLabel("üìö MEDIA LIBRARY")
        lib_title.setStyleSheet("font-size: 14pt; font-weight: bold; color: #4ade80; padding: 5px;")
        library_layout.addWidget(lib_title)
        self.media_list = QListWidget()
        self.media_list.setStyleSheet(self.list_style())
        self.media_list.itemClicked.connect(self.on_media_selected)
        library_layout.addWidget(self.media_list)
        lib_buttons = QHBoxLayout()
        add_media_btn = QPushButton("‚ûï Add Media")
        add_media_btn.setStyleSheet(self.button_style("#4ade80"))
        add_media_btn.setMinimumHeight(50)
        add_media_btn.clicked.connect(self.add_media_to_library)
        lib_buttons.addWidget(add_media_btn)
        remove_media_btn = QPushButton("‚ûñ Remove")
        remove_media_btn.setStyleSheet(self.button_style("#ef4444"))
        remove_media_btn.setMinimumHeight(50)
        remove_media_btn.clicked.connect(self.remove_from_library)
        lib_buttons.addWidget(remove_media_btn)
        library_layout.addLayout(lib_buttons)
        top_layout.addWidget(library_panel, stretch=1)
        preview_panel = QWidget()
        preview_layout = QVBoxLayout(preview_panel)
        preview_layout.setContentsMargins(5, 5, 5, 5)
        preview_title = QLabel("üé¨ PREVIEW")
        preview_title.setStyleSheet("font-size: 14pt; font-weight: bold; color: #3b82f6; padding: 5px;")
        preview_layout.addWidget(preview_title)
        self.video_widget = QVideoWidget()
        self.video_widget.setMinimumSize(640, 360)
        self.video_widget.setStyleSheet("background-color: black; border: 2px solid #4b5563; border-radius: 8px;")
        self.player.setVideoOutput(self.video_widget)
        preview_layout.addWidget(self.video_widget)
        self.preview_slider = QSlider(Qt.Orientation.Horizontal)
        self.preview_slider.setMinimum(0)
        self.preview_slider.setMaximum(1000)
        self.preview_slider.setStyleSheet(self.slider_style())
        self.preview_slider.sliderMoved.connect(self.seek_preview)
        preview_layout.addWidget(self.preview_slider)
        self.timecode_label = QLabel("00:00:00 / 00:00:00")
        self.timecode_label.setStyleSheet("font-size: 11pt; color: white; padding: 5px;")
        self.timecode_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        preview_layout.addWidget(self.timecode_label)
        controls_row = QHBoxLayout()
        self.play_btn = QPushButton("‚ñ∂Ô∏è Play")
        self.play_btn.setStyleSheet(self.button_style("#3b82f6"))
        self.play_btn.setMinimumHeight(50)
        self.play_btn.clicked.connect(self.toggle_play)
        controls_row.addWidget(self.play_btn)
        self.fullscreen_btn = QPushButton("‚õ∂ Fullscreen")
        self.fullscreen_btn.setStyleSheet(self.button_style("#8b5cf6"))
        self.fullscreen_btn.setMinimumHeight(50)
        self.fullscreen_btn.clicked.connect(self.enter_fullscreen)
        controls_row.addWidget(self.fullscreen_btn)
        preview_layout.addLayout(controls_row)
        trim_panel = QWidget()
        trim_layout = QVBoxLayout(trim_panel)
        trim_layout.setContentsMargins(5, 5, 5, 5)
        trim_title = QLabel("‚úÇÔ∏è TRIM POINTS")
        trim_title.setStyleSheet("font-size: 12pt; font-weight: bold; color: #fbbf24; padding: 5px;")
        trim_layout.addWidget(trim_title)
        trim_buttons = QHBoxLayout()
        set_in_btn = QPushButton("[ Set IN")
        set_in_btn.setStyleSheet(self.button_style("#10b981"))
        set_in_btn.setMinimumHeight(45)
        set_in_btn.clicked.connect(self.set_media_in_point)
        trim_buttons.addWidget(set_in_btn)
        set_out_btn = QPushButton("Set OUT ]")
        set_out_btn.setStyleSheet(self.button_style("#10b981"))
        set_out_btn.setMinimumHeight(45)
        set_out_btn.clicked.connect(self.set_media_out_point)
        trim_buttons.addWidget(set_out_btn)
        trim_layout.addLayout(trim_buttons)
        self.trim_info = QLabel("In: 00:00:00 | Out: 00:00:00 | Duration: 00:00:00")
        self.trim_info.setStyleSheet("font-size: 10pt; color: #9ca3af; padding: 5px;")
        self.trim_info.setAlignment(Qt.AlignmentFlag.AlignCenter)
        trim_layout.addWidget(self.trim_info)
        preview_layout.addWidget(trim_panel)
        top_layout.addWidget(preview_panel, stretch=2)
        layout.addWidget(top_section, stretch=3)
        timeline_section = QWidget()
        timeline_layout = QVBoxLayout(timeline_section)
        timeline_layout.setContentsMargins(5, 5, 5, 5)
        timeline_header = QHBoxLayout()
        timeline_title = QLabel("üéûÔ∏è TIMELINE")
        timeline_title.setStyleSheet("font-size: 14pt; font-weight: bold; color: #f59e0b; padding: 5px;")
        timeline_header.addWidget(timeline_title)
        timeline_header.addStretch()
        zoom_in_btn = QPushButton("üîç+")
        zoom_in_btn.setStyleSheet(self.button_style("#6366f1"))
        zoom_in_btn.setFixedSize(60, 40)
        zoom_in_btn.clicked.connect(self.zoom_in_timeline)
        timeline_header.addWidget(zoom_in_btn)
        zoom_out_btn = QPushButton("üîç‚àí")
        zoom_out_btn.setStyleSheet(self.button_style("#6366f1"))
        zoom_out_btn.setFixedSize(60, 40)
        zoom_out_btn.clicked.connect(self.zoom_out_timeline)
        timeline_header.addWidget(zoom_out_btn)
        timeline_layout.addLayout(timeline_header)
        self.timeline = TimelineWidget()
        self.timeline.setStyleSheet("background-color: #111827; border: 2px solid #4b5563; border-radius: 8px;")
        self.timeline.clip_selected.connect(self.on_timeline_clip_selected)
        self.timeline.playhead_moved.connect(self.on_timeline_playhead_moved)
        timeline_layout.addWidget(self.timeline, stretch=1)
        timeline_controls = QHBoxLayout()
        add_to_timeline_btn = QPushButton("‚ûï Add to Timeline")
        add_to_timeline_btn.setStyleSheet(self.button_style("#4ade80"))
        add_to_timeline_btn.setMinimumHeight(50)
        add_to_timeline_btn.clicked.connect(self.add_to_timeline)
        timeline_controls.addWidget(add_to_timeline_btn)
        remove_from_timeline_btn = QPushButton("‚ûñ Remove Clip")
        remove_from_timeline_btn.setStyleSheet(self.button_style("#ef4444"))
        remove_from_timeline_btn.setMinimumHeight(50)
        remove_from_timeline_btn.clicked.connect(self.remove_from_timeline)
        timeline_controls.addWidget(remove_from_timeline_btn)
        clear_timeline_btn = QPushButton("üóëÔ∏è Clear All")
        clear_timeline_btn.setStyleSheet(self.button_style("#dc2626"))
        clear_timeline_btn.setMinimumHeight(50)
        clear_timeline_btn.clicked.connect(self.clear_timeline)
        timeline_controls.addWidget(clear_timeline_btn)
        self.export_timeline_btn = QPushButton("üíæ EXPORT TIMELINE")
        self.export_timeline_btn.setStyleSheet(self.button_style("#8b5cf6"))
        self.export_timeline_btn.setMinimumHeight(50)
        self.export_timeline_btn.clicked.connect(self.export_timeline)
        timeline_controls.addWidget(self.export_timeline_btn)
        self.stop_export_btn = QPushButton("‚èπÔ∏è STOP RENDER")
        self.stop_export_btn.setStyleSheet(self.button_style("#ef4444"))
        self.stop_export_btn.setMinimumHeight(50)
        self.stop_export_btn.setEnabled(False)
        self.stop_export_btn.clicked.connect(self.stop_timeline_export)
        timeline_controls.addWidget(self.stop_export_btn)
        timeline_layout.addLayout(timeline_controls)
        layout.addWidget(timeline_section, stretch=2)
        self.player.positionChanged.connect(self.update_preview_position)
        self.player.durationChanged.connect(self.update_preview_duration)
        self.player.playbackStateChanged.connect(self.update_play_button)
        return tab

    def create_codec_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(15)
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("QScrollArea { border: none; background-color: #111827; }")
        scroll_content = QWidget()
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setSpacing(15)

        # Codec Selection
        codec_group = QGroupBox("üé• Video Codec")
        codec_group.setStyleSheet(self.groupbox_style())
        codec_layout = QVBoxLayout()
        codec_row = QHBoxLayout()
        codec_row.addWidget(QLabel("Codec:"))
        self.codec_combo = QComboBox()
        self.codec_combo.addItems(["ProRes", "H.264 (NVENC)", "H.265/HEVC (NVENC)"])
        self.codec_combo.setCurrentIndex(0)
        self.codec_combo.setStyleSheet(self.combo_style())
        self.codec_combo.currentIndexChanged.connect(self.on_codec_changed)
        codec_row.addWidget(self.codec_combo)
        codec_layout.addLayout(codec_row)

        # ProRes Profile
        prores_row = QHBoxLayout()
        self.prores_label = QLabel("ProRes Profile:")
        prores_row.addWidget(self.prores_label)
        self.prores_combo = QComboBox()
        self.prores_combo.addItems(["Proxy", "LT", "Standard", "HQ", "4444", "4444 XQ"])
        self.prores_combo.setCurrentIndex(5)
        self.prores_combo.setStyleSheet(self.combo_style())
        self.prores_combo.currentIndexChanged.connect(self.update_estimated_size)
        prores_row.addWidget(self.prores_combo)
        codec_layout.addLayout(prores_row)

        # NVENC Pixel Format
        nvenc_row = QHBoxLayout()
        self.nvenc_label = QLabel("Pixel Format:")
        nvenc_row.addWidget(self.nvenc_label)
        self.pixel_combo = QComboBox()
        self.pixel_combo.addItems(["8-bit (yuv420p)", "10-bit (p010le)"])
        self.pixel_combo.setCurrentIndex(1)
        self.pixel_combo.setStyleSheet(self.combo_style())
        nvenc_row.addWidget(self.pixel_combo)
        codec_layout.addLayout(nvenc_row)

        codec_group.setLayout(codec_layout)
        scroll_layout.addWidget(codec_group)

        # Timeline Settings Group
        timeline_group = QGroupBox("üéûÔ∏è Timeline Settings")
        timeline_group.setStyleSheet(self.groupbox_style())
        timeline_layout = QVBoxLayout()

        # Frame Rate
        fps_row = QHBoxLayout()
        fps_row.addWidget(QLabel("Timeline FPS:"))
        self.timeline_fps_combo = QComboBox()
        self.timeline_fps_combo.addItems(["23.976", "24", "25", "29.97", "30", "50", "60", "120"])
        self.timeline_fps_combo.setCurrentIndex(6)  # 60 fps default
        self.timeline_fps_combo.setStyleSheet(self.combo_style())
        fps_row.addWidget(self.timeline_fps_combo)
        timeline_layout.addLayout(fps_row)

        # Export Resolution
        res_row = QHBoxLayout()
        res_row.addWidget(QLabel("Export Resolution:"))
        self.export_res_combo = QComboBox()
        self.export_res_combo.addItems(["Source", "1920x1080", "2560x1440", "3840x2160", "5120x2880", "7680x4320"])
        self.export_res_combo.setCurrentIndex(0)
        self.export_res_combo.setStyleSheet(self.combo_style())
        res_row.addWidget(self.export_res_combo)
        timeline_layout.addLayout(res_row)

        # Upscale Algorithm
        scale_row = QHBoxLayout()
        scale_row.addWidget(QLabel("Upscale Quality:"))
        self.scale_algo_combo = QComboBox()
        self.scale_algo_combo.addItems(["Bilinear", "Bicubic", "Lanczos", "Spline"])
        self.scale_algo_combo.setCurrentIndex(2)  # Lanczos default
        self.scale_algo_combo.setStyleSheet(self.combo_style())
        scale_row.addWidget(self.scale_algo_combo)
        timeline_layout.addLayout(scale_row)

        timeline_group.setLayout(timeline_layout)
        scroll_layout.addWidget(timeline_group)


        # QUALITY SLIDER - The main control!
        quality_group = QGroupBox("üéØ Quality Bitrate Slider (CBR)")
        quality_group.setStyleSheet(self.groupbox_style())
        quality_layout = QVBoxLayout()

        quality_info = QLabel("Drag slider to set constant bitrate (Mbps). Higher = better quality & larger files.")
        quality_info.setStyleSheet("font-size: 9pt; color: #9ca3af; padding: 5px;")
        quality_info.setWordWrap(True)
        quality_layout.addWidget(quality_info)

        slider_row = QHBoxLayout()
        slider_row.addWidget(QLabel("Bitrate:"))

        self.quality_slider = QSlider(Qt.Orientation.Horizontal)
        self.quality_slider.setMinimum(1)
        self.quality_slider.setMaximum(1000)  # 1-1000 Mbps range
        self.quality_slider.setValue(100)  # Default 100 Mbps
        self.quality_slider.setStyleSheet(self.slider_style())
        self.quality_slider.valueChanged.connect(self.update_quality_label)
        slider_row.addWidget(self.quality_slider)

        self.quality_value_label = QLabel("100 Mbps")
        self.quality_value_label.setStyleSheet("font-size: 11pt; font-weight: bold; color: #4ade80; min-width: 100px;")
        slider_row.addWidget(self.quality_value_label)

        quality_layout.addLayout(slider_row)

        # Estimated file size display
        self.estimated_size_label = QLabel("Estimated Size: Calculating...")
        self.estimated_size_label.setStyleSheet("font-size: 12pt; font-weight: bold; color: #fbbf24; padding: 10px; background-color: #1f2937; border-radius: 5px;")
        self.estimated_size_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        quality_layout.addWidget(self.estimated_size_label)

        quality_group.setLayout(quality_layout)
        scroll_layout.addWidget(quality_group)

        # Audio
        audio_group = QGroupBox("üîä Audio")
        audio_group.setStyleSheet(self.groupbox_style())
        audio_layout = QVBoxLayout()
        audio_row = QHBoxLayout()
        audio_row.addWidget(QLabel("Audio Codec:"))
        self.audio_combo = QComboBox()
        self.audio_combo.addItems(["PCM 24-bit", "PCM 16-bit", "AAC 320kbps", "Copy Stream"])
        self.audio_combo.setStyleSheet(self.combo_style())
        audio_row.addWidget(self.audio_combo)
        audio_layout.addLayout(audio_row)
        audio_group.setLayout(audio_layout)
        scroll_layout.addWidget(audio_group)

        # Filters
        filters_group = QGroupBox("üé® Filters (Optional)")
        filters_group.setStyleSheet(self.groupbox_style())
        filters_layout = QVBoxLayout()
        denoise_row = QHBoxLayout()
        denoise_row.addWidget(QLabel("Denoise:"))
        self.denoise_combo = QComboBox()
        self.denoise_combo.addItems(["Off", "Light", "Medium", "Heavy", "Very Heavy", "Nuclear", "Ultra Nuclear"])
        self.denoise_combo.setStyleSheet(self.combo_style())
        denoise_row.addWidget(self.denoise_combo)
        filters_layout.addLayout(denoise_row)
        deflicker_row = QHBoxLayout()
        deflicker_row.addWidget(QLabel("Deflicker:"))
        self.deflicker_combo = QComboBox()
        self.deflicker_combo.addItems(["Off", "Light", "Medium", "Strong", "Very Strong", "Maximum"])
        self.deflicker_combo.setStyleSheet(self.combo_style())
        deflicker_row.addWidget(self.deflicker_combo)
        filters_layout.addLayout(deflicker_row)
        filters_group.setLayout(filters_layout)
        scroll_layout.addWidget(filters_group)

        # Performance
        perf_group = QGroupBox("‚ö° Performance")
        perf_group.setStyleSheet(self.groupbox_style())
        perf_layout = QVBoxLayout()
        self.gpu_check = QCheckBox("Enable GPU Acceleration (NVENC Encode)")
        self.gpu_check.setChecked(True)
        self.gpu_check.setStyleSheet("font-size: 11pt; color: white;")
        perf_layout.addWidget(self.gpu_check)

        self.gpu_decode_check = QCheckBox("Enable GPU Hardware Decode (CUDA/NVDEC)")
        self.gpu_decode_check.setChecked(True)
        self.gpu_decode_check.setStyleSheet("font-size: 11pt; color: white;")
        self.gpu_decode_check.stateChanged.connect(lambda: self.update_quality_label(self.quality_slider.value()))
        perf_layout.addWidget(self.gpu_decode_check)
        threads_row = QHBoxLayout()
        threads_row.addWidget(QLabel("CPU Threads (0=auto):"))
        self.threads_spin = QSpinBox()
        self.threads_spin.setRange(0, 64)
        self.threads_spin.setValue(0)
        self.threads_spin.setStyleSheet(self.spinbox_style())
        threads_row.addWidget(self.threads_spin)
        perf_layout.addLayout(threads_row)
        self.gpu_info = QLabel("‚úÖ ProRes 4444 XQ (~500 Mbps)")
        self.gpu_info.setStyleSheet("font-size: 10pt; color: #4ade80; font-weight: bold; padding: 5px;")
        perf_layout.addWidget(self.gpu_info)
        perf_group.setLayout(perf_layout)
        scroll_layout.addWidget(perf_group)

        reset_btn = QPushButton("üîÑ Reset All Settings")
        reset_btn.setStyleSheet(self.button_style("#ef4444"))
        reset_btn.setMinimumHeight(50)
        reset_btn.clicked.connect(self.reset_all)
        scroll_layout.addWidget(reset_btn)

        scroll_layout.addStretch()
        scroll.setWidget(scroll_content)
        layout.addWidget(scroll)
        self.on_codec_changed()
        self.update_quality_label(100)
        return tab

    def create_batch_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(15)
        files_group = QGroupBox("üìÅ Files")
        files_group.setStyleSheet(self.groupbox_style())
        files_layout = QVBoxLayout()
        self.file_list = QListWidget()
        self.file_list.setStyleSheet(self.list_style())
        files_layout.addWidget(self.file_list)
        file_buttons = QHBoxLayout()
        add_btn = QPushButton("‚ûï Add Files")
        add_btn.setStyleSheet(self.button_style("#4ade80"))
        add_btn.setMinimumHeight(50)
        add_btn.clicked.connect(self.add_files)
        file_buttons.addWidget(add_btn)
        remove_btn = QPushButton("‚ûñ Remove")
        remove_btn.setStyleSheet(self.button_style("#ef4444"))
        remove_btn.setMinimumHeight(50)
        remove_btn.clicked.connect(self.remove_selected)
        file_buttons.addWidget(remove_btn)
        clear_btn = QPushButton("üóëÔ∏è Clear All")
        clear_btn.setStyleSheet(self.button_style("#dc2626"))
        clear_btn.setMinimumHeight(50)
        clear_btn.clicked.connect(self.clear_files)
        file_buttons.addWidget(clear_btn)
        files_layout.addLayout(file_buttons)
        files_group.setLayout(files_layout)
        layout.addWidget(files_group)
        output_group = QGroupBox("üíæ Output")
        output_group.setStyleSheet(self.groupbox_style())
        output_layout = QVBoxLayout()
        output_row = QHBoxLayout()
        output_row.addWidget(QLabel("Folder:"))
        self.output_label = QLabel("Not selected")
        self.output_label.setStyleSheet("color: #9ca3af; padding: 5px;")
        output_row.addWidget(self.output_label, stretch=1)
        browse_btn = QPushButton("üìÇ Browse")
        browse_btn.setStyleSheet(self.button_style("#3b82f6"))
        browse_btn.setMinimumHeight(40)
        browse_btn.clicked.connect(self.select_output)
        output_row.addWidget(browse_btn)
        output_layout.addLayout(output_row)
        output_group.setLayout(output_layout)
        layout.addWidget(output_group)
        progress_group = QGroupBox("üìä Progress")
        progress_group.setStyleSheet(self.groupbox_style())
        progress_layout = QVBoxLayout()
        self.file_label = QLabel("")
        self.file_label.setStyleSheet("font-size: 11pt; color: white; padding: 5px;")
        progress_layout.addWidget(self.file_label)
        self.progress_bar = QProgressBar()
        self.progress_bar.setStyleSheet("""
            QProgressBar { border: 2px solid #4b5563; border-radius: 8px; background-color: #1f2937;
                text-align: center; font-size: 10pt; color: white; min-height: 30px; }
            QProgressBar::chunk { background-color: #4ade80; border-radius: 6px; }
        """)
        progress_layout.addWidget(self.progress_bar)
        self.status_label = QLabel("Ready")
        self.status_label.setStyleSheet("font-size: 10pt; color: #9ca3af; padding: 5px;")
        progress_layout.addWidget(self.status_label)
        progress_group.setLayout(progress_layout)
        layout.addWidget(progress_group)
        log_group = QGroupBox("üìù Log")
        log_group.setStyleSheet(self.groupbox_style())
        log_layout = QVBoxLayout()
        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        self.log_text.setStyleSheet("""
            QTextEdit { background-color: #0f1419; color: #4ade80; font-family: 'Courier New', monospace;
                font-size: 9pt; border: 2px solid #4b5563; border-radius: 8px; padding: 5px; }
        """)
        log_layout.addWidget(self.log_text)
        log_group.setLayout(log_layout)
        layout.addWidget(log_group)
        control_buttons = QHBoxLayout()
        self.start_btn = QPushButton("‚ñ∂Ô∏è START ENCODING")
        self.start_btn.setStyleSheet(self.button_style("#4ade80"))
        self.start_btn.setMinimumHeight(60)
        self.start_btn.clicked.connect(self.start_encoding)
        control_buttons.addWidget(self.start_btn)
        self.stop_btn = QPushButton("‚èπÔ∏è STOP")
        self.stop_btn.setStyleSheet(self.button_style("#ef4444"))
        self.stop_btn.setMinimumHeight(60)
        self.stop_btn.setEnabled(False)
        self.stop_btn.clicked.connect(self.stop_encoding)
        control_buttons.addWidget(self.stop_btn)
        layout.addLayout(control_buttons)
        return tab

    def add_media_to_library(self):
        files, _ = QFileDialog.getOpenFileNames(self, "Select Media Files", "", "Videos (*.mp4 *.mov *.avi *.mkv *.mts *.m2ts);;All (*.*)")
        for f in files:
            if not any(m.file_path == f for m in self.media_library):
                media = MediaLibraryItem(f)
                self.media_library.append(media)
                self.media_list.addItem(media.name)

    def remove_from_library(self):
        row = self.media_list.currentRow()
        if row >= 0:
            self.media_list.takeItem(row)
            del self.media_library[row]
            if self.current_media and row == self.media_library.index(self.current_media) if self.current_media in self.media_library else False:
                self.current_media = None
                self.player.stop()

    def on_media_selected(self, item):
        row = self.media_list.row(item)
        if 0 <= row < len(self.media_library):
            self.current_media = self.media_library[row]
            self.player.setSource(QUrl.fromLocalFile(self.current_media.file_path))
            self.player.pause()
            self.update_trim_info()

    def on_timeline_clip_selected(self, clip):
        self.player.setSource(QUrl.fromLocalFile(clip.file_path))
        self.player.setPosition(int(clip.in_point * 1000))
        self.player.pause()
        in_tc = self.format_timecode(int(clip.in_point * 1000))
        out_tc = self.format_timecode(int(clip.out_point * 1000))
        dur_tc = self.format_timecode(int(clip.get_trimmed_duration() * 1000))
        self.trim_info.setText(f"Timeline Clip | In: {in_tc} | Out: {out_tc} | Duration: {dur_tc}")

    def on_timeline_playhead_moved(self, time):
        pass

    def toggle_play(self):
        if self.player.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
            self.player.pause()
        else:
            self.player.play()

    def update_play_button(self):
        if self.player.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
            self.play_btn.setText("‚è∏Ô∏è Pause")
        else:
            self.play_btn.setText("‚ñ∂Ô∏è Play")

    def seek_preview(self, value):
        if self.player.duration() > 0:
            position = int((value / 1000.0) * self.player.duration())
            self.player.setPosition(position)

    def update_preview_position(self, position):
        if self.player.duration() > 0:
            value = int((position / self.player.duration()) * 1000)
            self.preview_slider.setValue(value)
        self.timecode_label.setText(f"{self.format_timecode(position)} / {self.format_timecode(self.player.duration())}")

    def update_preview_duration(self, duration):
        self.preview_slider.setMaximum(1000)
        self.timecode_label.setText(f"{self.format_timecode(self.player.position())} / {self.format_timecode(duration)}")

    def format_timecode(self, ms):
        s = ms // 1000
        h = s // 3600
        m = (s % 3600) // 60
        s = s % 60
        return f"{h:02d}:{m:02d}:{s:02d}"

    def enter_fullscreen(self):
        if self.current_media or self.player.source().isValid():
            self.fullscreen_player = FullscreenVideoPlayer(self.player, self)
            self.fullscreen_player.show()

    def set_media_in_point(self):
        if self.current_media:
            self.current_media.in_point = self.player.position() / 1000.0
            if self.current_media.out_point <= self.current_media.in_point:
                self.current_media.out_point = self.current_media.duration
            self.update_trim_info()

    def set_media_out_point(self):
        if self.current_media:
            self.current_media.out_point = self.player.position() / 1000.0
            if self.current_media.out_point <= self.current_media.in_point:
                self.current_media.in_point = 0
            self.update_trim_info()

    def update_trim_info(self):
        if self.current_media:
            in_tc = self.format_timecode(int(self.current_media.in_point * 1000))
            out_tc = self.format_timecode(int(self.current_media.out_point * 1000))
            dur_tc = self.format_timecode(int(self.current_media.get_trimmed_duration() * 1000))
            self.trim_info.setText(f"In: {in_tc} | Out: {out_tc} | Duration: {dur_tc}")

    def add_to_timeline(self):
        if not self.current_media:
            QMessageBox.warning(self, "No Media", "Select media from library first")
            return
        next_time = 0
        if self.timeline.clips:
            last_clip = max(self.timeline.clips, key=lambda c: c.get_end_time())
            next_time = last_clip.get_end_time()
        clip = TimelineClip(self.current_media.file_path, 0, next_time, self.current_media.in_point, self.current_media.out_point, self.current_media.duration)
        self.timeline.add_clip(clip)
        self.update_timeline_duration()

    def remove_from_timeline(self):
        if self.timeline.selected_clip:
            self.timeline.remove_clip(self.timeline.selected_clip)
            self.update_timeline_duration()

    def clear_timeline(self):
        reply = QMessageBox.question(self, "Clear Timeline", "Remove all clips from timeline?", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.Yes:
            self.timeline.clear_timeline()
            self.update_timeline_duration()

    def update_timeline_duration(self):
        if self.timeline.clips:
            self.timeline_duration = sum(clip.get_trimmed_duration() for clip in self.timeline.clips)
        else:
            self.timeline_duration = 0
        self.update_estimated_size()

    def zoom_in_timeline(self):
        self.timeline.zoom_in()

    def zoom_out_timeline(self):
        self.timeline.zoom_out()

    def on_codec_changed(self):
        idx = self.codec_combo.currentIndex()
        is_prores = idx == 0
        is_nvenc = idx in [1, 2]
        self.prores_label.setVisible(is_prores)
        self.prores_combo.setVisible(is_prores)
        self.nvenc_label.setVisible(is_nvenc)
        self.pixel_combo.setVisible(is_nvenc)

        if is_prores:
            # ProRes typical bitrates
            self.quality_slider.setMinimum(50)
            self.quality_slider.setMaximum(1000)
            self.quality_slider.setValue(500)
            self.update_quality_label(500)
        else:
            # NVENC typical bitrates
            self.quality_slider.setMinimum(5)
            self.quality_slider.setMaximum(500)
            self.quality_slider.setValue(100)
            self.update_quality_label(100)

        self.update_estimated_size()

    def update_quality_label(self, value):
        self.quality_value_label.setText(f"{value} Mbps")
        self.update_estimated_size()

        # Update GPU info
        codec_idx = self.codec_combo.currentIndex()
        decode_status = "HW Decode ON" if self.gpu_decode_check.isChecked() else "SW Decode"
        if codec_idx == 0:  # ProRes
            profile_names = ["Proxy", "LT", "Standard", "HQ", "4444", "4444 XQ"]
            self.gpu_info.setText(f"‚úÖ ProRes {profile_names[self.prores_combo.currentIndex()]} (~{value} Mbps CBR) | {decode_status}")
        else:  # NVENC
            self.gpu_info.setText(f"‚úÖ GPU: NVENC ({value} Mbps CBR) | {decode_status}")

    def update_estimated_size(self):
        if self.timeline_duration > 0:
            duration = self.timeline_duration
        else:
            duration = 60  # Default estimate for 1 minute

        bitrate_mbps = self.quality_slider.value()
        video_size_mb = (bitrate_mbps * duration) / 8

        # Add audio size estimate (320kbps AAC or 2304kbps PCM 24-bit)
        audio_codec_idx = self.audio_combo.currentIndex()
        if audio_codec_idx == 2:  # AAC
            audio_bitrate_kbps = 320
        elif audio_codec_idx in [0, 1]:  # PCM
            audio_bitrate_kbps = 2304  # 48kHz * 24bit * 2 channels
        else:
            audio_bitrate_kbps = 320  # Default estimate

        audio_size_mb = (audio_bitrate_kbps * duration) / (8 * 1024)

        total_size_mb = video_size_mb + audio_size_mb
        total_size_gb = total_size_mb / 1024

        if self.timeline_duration > 0:
            self.estimated_size_label.setText(f"Estimated Size: {total_size_gb:.2f} GB ({total_size_mb:.0f} MB) for {duration:.1f}s timeline")
        else:
            self.estimated_size_label.setText(f"Estimated Size: ~{total_size_gb:.2f} GB per minute")

    def export_timeline(self):
        if not self.timeline.clips:
            QMessageBox.warning(self, "Empty Timeline", "Add clips to timeline before exporting")
            return
        settings = self.get_settings()
        ext = ".mov"
        output_file, _ = QFileDialog.getSaveFileName(self, "Export Timeline As", f"timeline_export{ext}", f"Video Files (*{ext})")
        if not output_file:
            return

        bitrate = self.quality_slider.value()
        reply = QMessageBox.question(self, "Export Timeline", f"Export {len(self.timeline.clips)} clips?\n\nCodec: {settings['video_codec'].upper()}\nBitrate: {bitrate} Mbps (CBR - Constant)\nContainer: MOV\n\n‚úÖ This will maintain consistent quality throughout!", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if reply != QMessageBox.StandardButton.Yes:
            return
        self.export_timeline_btn.setEnabled(False)
        self.stop_export_btn.setEnabled(True)
        self.timeline_export_thread = TimelineExportThread(self.timeline, output_file, settings)
        self.timeline_export_thread.progress.connect(self.progress_bar.setValue)
        self.timeline_export_thread.status.connect(self.status_label.setText)
        self.timeline_export_thread.log_message.connect(self.append_log)
        self.timeline_export_thread.finished.connect(self.timeline_export_done)
        self.timeline_export_thread.playhead_update.connect(self.timeline.set_playhead_position)  # NEW: Update playhead during render
        self.progress_bar.setValue(0)
        self.status_label.setText("Exporting with CBR...")
        self.timeline_export_thread.start()

    def timeline_export_done(self, success, msg):
        self.export_timeline_btn.setEnabled(True)
        self.stop_export_btn.setEnabled(False)
        if success:
            QMessageBox.information(self, "Export Complete", msg)
            self.progress_bar.setValue(100)
        else:
            if "stopped" not in msg.lower():
                QMessageBox.warning(self, "Export Failed", msg)
        self.status_label.setText("Ready")

    def stop_timeline_export(self):
        """Safely stop timeline rendering with timeout"""
        if self.timeline_export_thread and self.timeline_export_thread.isRunning():
            self.status_label.setText("Stopping render...")
            self.stop_export_btn.setEnabled(False)
            
            # Signal stop to the rendering engine
            self.timeline_export_thread.stop()
            
            # Wait with timeout (5 seconds)
            if not self.timeline_export_thread.wait(5000):
                # Force termination if not stopped gracefully
                self.timeline_export_thread.terminate()
                self.timeline_export_thread.wait()
            
            # Reset UI
            self.export_timeline_btn.setEnabled(True)
            self.stop_export_btn.setEnabled(False)
            self.status_label.setText("Render stopped")
            self.log_text.append("\\n=== Render cancelled by user ===\\n")

    def apply_theme(self):
        self.setStyleSheet("""
            QMainWindow { background-color: #111827; }
            QWidget { background-color: #111827; color: white; font-size: 10pt; }
            QLabel { color: white; }
            QGroupBox { font-weight: bold; }
        """)

    def tab_style(self):
        return """
            QTabWidget::pane { border: 2px solid #4b5563; background-color: #111827; border-radius: 8px; }
            QTabBar::tab { background-color: #1f2937; color: white; padding: 12px 24px; margin: 2px;
                border-top-left-radius: 8px; border-top-right-radius: 8px; font-size: 11pt; font-weight: bold; }
            QTabBar::tab:selected { background-color: #3b82f6; color: white; }
            QTabBar::tab:hover { background-color: #374151; }
        """

    def groupbox_style(self):
        return """
            QGroupBox { background-color: #1f2937; border: 2px solid #4b5563; border-radius: 10px;
                padding: 15px; margin-top: 10px; font-size: 11pt; font-weight: bold; color: #4ade80; }
            QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top left; padding: 5px 10px;
                background-color: #111827; border-radius: 5px; }
        """

    def button_style(self, color):
        hover = self.brighten(color, 1.2)
        pressed = self.brighten(color, 0.8)
        return f"""
            QPushButton {{ background-color: {color}; color: white; border: none; border-radius: 10px;
                padding: 8px 16px; font-size: 11pt; font-weight: bold; }}
            QPushButton:hover {{ background-color: {hover}; }}
            QPushButton:pressed {{ background-color: {pressed}; }}
            QPushButton:disabled {{ background-color: #4b5563; color: #9ca3af; }}
        """

    def list_style(self):
        return """
            QListWidget { background-color: #1f2937; border: 2px solid #4b5563; border-radius: 8px;
                padding: 5px; font-size: 10pt; color: white; }
            QListWidget::item { padding: 8px; border-radius: 5px; }
            QListWidget::item:selected { background-color: #3b82f6; color: white; }
            QListWidget::item:hover { background-color: #374151; }
        """

    def slider_style(self):
        return """
            QSlider::groove:horizontal { border: none; height: 12px; background: #4b5563; border-radius: 6px; }
            QSlider::handle:horizontal { background: #4ade80; border: 3px solid white; width: 24px;
                height: 24px; margin: -6px 0; border-radius: 12px; }
            QSlider::sub-page:horizontal { background: #4ade80; border-radius: 6px; }
        """

    def combo_style(self):
        return """
            QComboBox { background-color: #1f2937; border: 2px solid #4b5563; border-radius: 8px;
                padding: 6px; font-size: 10pt; color: white; }
            QComboBox::drop-down { border: none; width: 30px; }
            QComboBox::down-arrow { image: none; border-left: 5px solid transparent; border-right: 5px solid transparent;
                border-top: 8px solid white; margin-right: 8px; }
            QComboBox QAbstractItemView { background-color: #1f2937; border: 2px solid #4b5563;
                selection-background-color: #4ade80; selection-color: black; color: white; padding: 5px; }
        """

    def spinbox_style(self):
        return """
            QSpinBox, QDoubleSpinBox { background-color: #1f2937; border: 2px solid #4b5563; border-radius: 8px;
                padding: 6px; font-size: 10pt; color: white; }
            QSpinBox::up-button, QSpinBox::down-button, QDoubleSpinBox::up-button, QDoubleSpinBox::down-button { width: 20px; background-color: #4b5563; }
        """

    def brighten(self, hex_color, factor):
        hex_color = hex_color.lstrip('#')
        r, g, b = [int(hex_color[i:i+2], 16) for i in (0, 2, 4)]
        r, g, b = [min(255, max(0, int(c * factor))) for c in (r, g, b)]
        return f"#{r:02x}{g:02x}{b:02x}"

    def add_files(self):
        files, _ = QFileDialog.getOpenFileNames(self, "Select Videos", "", "Videos (*.mp4 *.mov *.avi *.mkv *.mts *.m2ts);;All (*.*)")
        for f in files:
            if f not in self.input_files:
                self.input_files.append(f)
                self.file_list.addItem(Path(f).name)

    def remove_selected(self):
        row = self.file_list.currentRow()
        if row >= 0:
            self.file_list.takeItem(row)
            del self.input_files[row]

    def clear_files(self):
        self.input_files.clear()
        self.file_list.clear()

    def select_output(self):
        folder = QFileDialog.getExistingDirectory(self, "Select Output")
        if folder:
            self.output_folder = folder
            self.output_label.setText(folder)

    def reset_all(self):
        self.codec_combo.setCurrentIndex(0)
        self.prores_combo.setCurrentIndex(5)
        self.pixel_combo.setCurrentIndex(1)
        self.audio_combo.setCurrentIndex(0)
        self.gpu_check.setChecked(True)
        self.gpu_decode_check.setChecked(True)
        self.threads_spin.setValue(0)
        self.quality_slider.setValue(500 if self.codec_combo.currentIndex() == 0 else 100)
        self.denoise_combo.setCurrentIndex(0)
        self.deflicker_combo.setCurrentIndex(0)
        self.on_codec_changed()

    def get_settings(self):
        codec_map = {0: "prores_ks", 1: "h264_nvenc", 2: "hevc_nvenc"}
        audio_map = {0: "pcm_s24le", 1: "pcm_s16le", 2: "aac", 3: "copy"}
        
        # Parse timeline FPS
        fps_values = [23.976, 24, 25, 29.97, 30, 50, 60, 120]
        timeline_fps = fps_values[self.timeline_fps_combo.currentIndex()]
        
        # Parse export resolution
        export_res_index = self.export_res_combo.currentIndex()
        
        # Parse scale algorithm
        scale_algos = ['bilinear', 'bicubic', 'lanczos', 'spline']
        scale_algo = scale_algos[self.scale_algo_combo.currentIndex()]
        
        settings = {
            'video_codec': codec_map[self.codec_combo.currentIndex()],
            'prores_profile': self.prores_combo.currentIndex(),
            'pixel_format': self.pixel_combo.currentIndex(),
            'audio_codec': audio_map[self.audio_combo.currentIndex()],
            'use_gpu': self.gpu_check.isChecked(),
            'use_gpu_decode': self.gpu_decode_check.isChecked(),
            'threads': self.threads_spin.value(),
            'bitrate_mbps': self.quality_slider.value(),
            'denoise_level': self.denoise_combo.currentIndex(),
            'deflicker_level': self.deflicker_combo.currentIndex(),
            'timeline_fps': timeline_fps,
            'export_res_index': export_res_index,
            'scale_algo': scale_algo,
        }
        return settings

    def start_encoding(self):
        if not self.input_files:
            QMessageBox.warning(self, "No Files", "Add files")
            return
        if not self.output_folder:
            QMessageBox.warning(self, "No Output", "Select folder")
            return
        self.current_file_index = 0
        self.encode_next()

    def encode_next(self):
        if self.current_file_index >= len(self.input_files):
            self.encoding_done(True, f"All {len(self.input_files)} done!")
            return
        inp = self.input_files[self.current_file_index]
        settings = self.get_settings()
        ext = ".mov"
        out_name = f"{Path(inp).stem}_encoded{ext}"
        out_path = os.path.join(self.output_folder, out_name)
        counter = 1
        while os.path.exists(out_path):
            out_name = f"{Path(inp).stem}_encoded_{counter}{ext}"
            out_path = os.path.join(self.output_folder, out_name)
            counter += 1
        self.file_label.setText(f"File {self.current_file_index + 1}/{len(self.input_files)}: {Path(inp).name}")
        self.encoding_thread = EncodingThread(inp, out_path, settings)
        self.encoding_thread.progress.connect(self.progress_bar.setValue)
        self.encoding_thread.status.connect(self.status_label.setText)
        self.encoding_thread.log_message.connect(self.append_log)
        self.encoding_thread.finished.connect(self.file_done)
        self.start_btn.setEnabled(False)
        self.stop_btn.setEnabled(True)
        self.progress_bar.setValue(0)
        self.encoding_thread.start()

    def file_done(self, success, msg):
        if success:
            self.current_file_index += 1
            self.encode_next()
        else:
            self.encoding_done(False, msg)

    def stop_encoding(self):
        if self.encoding_thread:
            self.encoding_thread.stop()
            self.encoding_thread.wait()
        self.encoding_done(False, "Stopped")

    def append_log(self, text):
        self.log_text.append(text)
        sb = self.log_text.verticalScrollBar()
        sb.setValue(sb.maximum())

    def encoding_done(self, success, msg):
        self.start_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        if success:
            QMessageBox.information(self, "Complete", msg)
            self.progress_bar.setValue(100)
        elif "stopped" not in msg.lower():
            QMessageBox.warning(self, "Issue", msg)
        self.status_label.setText("Ready")
        self.file_label.setText("")
        self.current_file_index = 0

    def save_settings(self):
        pass

    def load_settings(self):
        pass

    def closeEvent(self, event):
        if self.encoding_thread and self.encoding_thread.isRunning():
            reply = QMessageBox.question(self, "Active", "Stop and quit?", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.No:
                event.ignore()
                return
            self.encoding_thread.stop()
            self.encoding_thread.wait()
        if self.timeline_export_thread and self.timeline_export_thread.isRunning():
            reply = QMessageBox.question(self, "Export Active", "Stop export and quit?", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.No:
                event.ignore()
                return
            self.timeline_export_thread.stop()
            self.timeline_export_thread.wait()
        event.accept()


def main():
    app = QApplication(sys.argv)
    app.setStyle("Fusion")
    window = FastEncodeProApp()
    window.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
